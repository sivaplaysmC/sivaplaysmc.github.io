<canvas id="bg-canvas" hx-preserve=true></canvas>

<style>
    html,
    body {
        background: transparent !important;
    }

    #bg-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
    }

    .home-hero {
        font-family: "IBM Plex Mono";
        font-weight: 500;
        position: relative;
        z-index: 1;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.9);
        color: white; /* Added for visibility */
        padding: 20px;
    }
</style>

<script>
    (function () {
        const canvas = document.getElementById("bg-canvas");
        const c = canvas.getContext("2d", { alpha: false });

        let particleCount = 200;
        let lightParticles = [];
        let speed = 0.000001;
        const maxSpeed = 0.0006;
        const minSpeed = 0.00001;
        let isMouseDown = false;

        const colors = ["#00FF66", "#ffffff", "#00CC44", "#33FF99", "#66FFAA", "#00FF88"];

        // Connection settings
        const connectionDistance = 50; // Max distance to connect
        const connectionDistanceSq = connectionDistance * connectionDistance; // Squared optimization

        class LightParticle {
            constructor(angle, radius, size, color) {
                this.angle = angle;
                this.radius = radius;
                this.size = size;
                this.color = color;
                this.angleVelocity = (Math.random() - 0.5) * 0.01;
                this.radiusVelocity = (Math.random() - 0.5) * 0.5;
                // Cache cartesian coordinates
                this.x = 0;
                this.y = 0;
            }

            update(rotationSpeed, centerX, centerY) {
                this.angle += rotationSpeed + this.angleVelocity;
                this.radius += this.radiusVelocity;

                const minRadius = 50;
                const maxRadius = Math.min(canvas.width, canvas.height) * 0.45;

                if (this.radius < minRadius || this.radius > maxRadius) {
                    this.radiusVelocity *= -1;
                }

                // Calculate and store Cartesian position once per frame
                this.x = centerX + Math.cos(this.angle) * this.radius;
                this.y = centerY + Math.sin(this.angle) * this.radius;
            }

            draw(ctx) {
                // Rounding pixels improves rendering performance slightly
                const px = Math.round(this.x);
                const py = Math.round(this.y);
                ctx.fillRect(px, py, this.size, this.size);
            }
        }

        function initializeParticles() {
            lightParticles = [];
            const maxRadius = Math.min(canvas.width, canvas.height) * 1;
            const minRadius = 10;

            for (let i = 0; i < particleCount; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                const size = Math.random() * 4 + 1;
                const angle = Math.random() * Math.PI * 2;
                const radius = minRadius + Math.pow(Math.random(), 0.7) * (maxRadius - minRadius);
                lightParticles.push(new LightParticle(angle, radius, size, color));
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initializeParticles();
        }

        function animate() {
            requestAnimationFrame(animate);

            const targetSpeed = isMouseDown ? maxSpeed : 0.001;
            speed += (targetSpeed - speed) * 0.02;
            speed = Math.min(maxSpeed, Math.max(minSpeed, speed));

            const halfWidth = canvas.width / 2;
            const halfHeight = canvas.height / 2;

            // Clear background
            c.fillStyle = "#000";
            c.fillRect(0, 0, canvas.width, canvas.height);

            // 1. Update Positions & Cache Coordinates
            for (let particle of lightParticles) {
                particle.update(speed, halfWidth, halfHeight);
            }

            // 2. Draw Connections (Batch Drawing)
            c.strokeStyle = "rgba(78, 238, 133, 0.38)";
            c.lineWidth = 0.5;
            c.beginPath();

            for (let i = 0; i < lightParticles.length; i++) {
                let connections = 0;
                const p1 = lightParticles[i];

                for (let j = i + 1; j < lightParticles.length; j++) {
                    const p2 = lightParticles[j];

                    // Fast distance check (Squared Euclidean)
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distSq = dx * dx + dy * dy;

                    if (distSq < connectionDistanceSq) {
                        c.moveTo(p1.x, p1.y);
                        c.lineTo(p2.x, p2.y);
                        connections++;

                        if (connections >= 2) break;
                    }
                }
            }
            c.stroke();

            // 3. Draw Particles (Grouped by color for performance)
            const particlesByColor = {};
            for (let particle of lightParticles) {
                if (!particlesByColor[particle.color]) particlesByColor[particle.color] = [];
                particlesByColor[particle.color].push(particle);
            }

            for (let color in particlesByColor) {
                c.fillStyle = color;
                for (let particle of particlesByColor[color]) {
                    particle.draw(c);
                }
            }
        }

        window.addEventListener("mousedown", () => (isMouseDown = true));
        window.addEventListener("mouseup", () => (isMouseDown = false));
        window.addEventListener("resize", resizeCanvas);

        resizeCanvas();
        animate();
    })();
</script>
